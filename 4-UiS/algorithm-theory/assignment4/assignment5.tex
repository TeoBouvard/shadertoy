\documentclass[a4paper, 10pt, twoside]{article}
\usepackage[left=2cm, right=2cm, top=2cm, bottom=3cm]{geometry}
\usepackage{amsmath}
\usepackage[shortlabels]{enumitem}
\usepackage{clrscode3e}

\begin{document}

\title{Algorithm Theory - Theoretical exercise 5}
\author{T\'eo Bouvard}
\maketitle

\section*{Problem 1}

Since we deal with a directed acyclic graph, we can use the acyclic property to count the number of paths from a source node to a target node recursively. If use memoization, we can avoid solving overlapping subproblems. However, we can also solve this problem by using a bottom-up approach, using the same idea we used for computing the Fibonacci sequence in the previous assignment.
We start at the target node with a number of paths equal to one, and add the node's counter to its parents while adding them to FIFO queue if they have not already been visited. If we do that until the queue is empty, we have the number of paths from every node in the graph to the target, while still having a linear complexity. An example implementation is given below. For simplicity, we assume that we have access to a FIFO data structure, and that the graph data structure can retrieve the predecessors of a node. Furthermore, we assume that nodes are objects with an $already\_visited$ attribute. If that was not the case, we could still maintain a separate list of already visited nodes.

\begin{codebox}
	\Procname{$\proc{n-paths}$(G, s, t)}
	\zi let $n[0 \ldots length(G.V) - 1]$ be a zero-initialized array 
	\zi queue = FIFO()
	\zi queue.enqueue(t)
	\zi n[t] = 1
	\zi \While queue.empty() = $\const{false}$ \Do
	\zi current = queue.dequeue()
	\zi pred = G.predecessors(current)
	\zi \For p $\in$ pred \Do
	\zi \If p.already\_visited = $\const{false}$ \Do
	\zi queue.enqueue(p)
	\zi p.already\_visited = $\const{true}$ \End
	\zi n[p] += n[current] \End \End
	\zi \Return n[s] \End
\end{codebox}

This algorithm has complexity $\mathcal{O}(V+E)$ because it considers each node and its predecessors at most once. In fact it is nearly identical to a BFS, except that its goal is to count paths rather than searching for a particular node.

\section*{Problem 2}
\begin{enumerate}[a)]
	\item 
	
\end{enumerate}

\end{document}
